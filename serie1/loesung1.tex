\documentclass[a4paper]{scrartcl}
\usepackage[ngerman]{babel} %deutsch
\usepackage[utf8]{inputenc} %Umlaute
\usepackage{xcolor,graphicx} %grafike inelade
\usepackage{fancyhdr}
\usepackage{float}
\usepackage{units}
\usepackage{textcomp}
\usepackage{amstext}
\usepackage{graphicx}
\usepackage[pdftex]{hyperref}  %verlinkige, immer zungerscht!
\input{../tex/source_format} % sourcecode formatierung

\providecommand{\tabularnewline}{\\}

\title{Rechnerarchitektur Serie 1}
\author{Dominik Bodenmann 08-103-053\\
	Orlando Signer 12-119-715\\}


\begin{document}
\maketitle

\section{Theorieteil}

\subsection{Aufgabe 1}
5 Bytes, 4 Bytes für die Zeichen (T,e,s,t) und 1 Byte für \textbackslash0.

\subsection{Aufgabe 2}
\begin{lstlisting}[caption=int-Array]
int a[10];

int getAt(int i) {
	return a[i];
}

int getAtWithPointer(int *a, int i) {
	return *(a+i);
}
\end{lstlisting}

\begin{lstlisting}[caption=short-Array]
short a[10];

short getAt(int i) {
	return a[i];
}

short getAtWithPointer(short *a, int i) {
	return *(a+i);
}
\end{lstlisting}

Bei Pointern beziehen sich die Rechenoperationen immer auf die Breite des Variablentyps (short 2 Byte, int 4 Byte). Somit zeigt auch *(a+i) auf die i-te Stelle im Array, egal ob es sich um ein short- oder int-array handelt.
\newpage
\subsection{Aufgabe 3}
\begin{lstlisting}[caption=Ausgabe]
bffff844
3ade68b1
68
de
bffff847
\end{lstlisting}

\begin{enumerate}
	\item Der Wert von p: Die erste Speicheradresse von b.
	\item p wird als long (4 Bytes) dereferenziert und danach inkrementiert. Da p vom Typ void ist, wird er nur um 1 erhöht.
	\item p wird als char (1 Byte) dereferenziert und danach inkrementiert.
	\item p wird als unsigned char (1 Byte) dereferenziert und danach inkrementiert.
	\item Der Wert von p: Die 4. Speicheradresse von b.
\end{enumerate}

\subsection{Aufgabe 4}
Preincrement: i = 1338, j = 1338 \\
Postincrement: i = 1338, j = 1337

\subsection{Aufgabe 5}
1. Codestück
\begin{itemize}
	\item 3. Zeile: x und px werden dereferenziert, es zeigen beide auf die 0. Stelle im Array. Ausgabe: "1 1"
	\item 5. Zeile: px wurde inkrementiert, zeigt jetzt auf die 1. Stelle. Ausgabe: "1 2"
\end{itemize}


2. Codestück
\begin{verbatim}
*(py--) = 10;
\end{verbatim} setzt zuerst y auf 10, danach wird py dekrementiert und auf 11 gesetzt. Die Ausgabe ist also "10 11"

\subsection{Aufgabe 6}
Grösse des structs: 4 * 1 Byte + 2 * 1 Byte + 2 Byte = 8 Bytes \\
Grösse des union: max( 8 * 1 Byte, 4 Byte, 2 Byte) = 8 Bytes \\\\
Speicheraufteilung struct\\
\begin{array}{|c|c|c|c|c|c|c|c|}
\hline 
d&d&c&b&a[3]&a[2]&a[1]&a[0]\\
\hline
\end{array}

Speicheraufteilung union\\
\begin{array}{|c|c|c|c|c|c|c|c|}
\hline 
a[7]/d[3]&a[6]/d[3]&a[5]/d[2]&a[4]/d[2]&a[3]/d[1]/b&a[2]/d[1]/b&a[1]/d[0]/b&a[0]/d[0]/b\\
\hline
\end{array}

\subsection{Aufgabe 7}
Define ist eine Art Search-Replace Mechanismus und findet vor dem Compilieren statt. (praktisch f"ur Konstanten)//
Das Programmierst"uck gibt 3 aus.

\section{Programmierteil}
\lstinputlisting{src/cSerie1.c}


\end{document}
