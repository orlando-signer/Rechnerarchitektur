\documentclass[a4paper,abstracton]{scrartcl}
\usepackage[ngerman]{babel} %deutsch
\usepackage[utf8]{inputenc} %Umlaute
\usepackage{amsmath} %math
\usepackage{amsfonts} %math
\usepackage{amssymb} %math
\usepackage{xcolor,graphicx} %grafike inelade
\usepackage{fancyhdr}
\usepackage{float}
\usepackage{units}
\usepackage{textcomp}
\usepackage{amstext}
\usepackage{graphicx}
\usepackage[pdftex]{hyperref}  %verlinkige, immer zungerscht!
\input{../tex/source_format} % sourcecode formatierung

\providecommand{\tabularnewline}{\\}

\title{Rechnerarchitektur Serie 3}
\author{Dominik Bodenmann 08-103-053\\
	Orlando Signer 12-119-715\\}


\begin{document}
\maketitle

\section{Theorie-Teil}
\subsection{Aufgabe 1}
$
\begin{array}{l|c|c|c|c||c|c||c|c|}
 & t & Freq & CPI & Freq*CPI & CPI & Freq*CPI & CPI & Freq*CPI\\
\hline
ALU & 5nsec & 25\% & 2 & 0.5 & 2 & 0.5 & {\bf 1} & 0.25\\
LOAD & 10nsec & 25\% & 4 & 1.0 & {\bf 6} & 1.5 & 4 & 1.0\\
STORE & 7.5nsec & 25\% & 3 & 0.75 & 3 & 0.75 & 1 & 0.75\\
Branch & 7.5nsec & 25\% & 3 & 0.75 & 3 & 0.75 & 1 & 0.75\\
\hline
 & & & & 3.0 & & 3.5 & & 2.75\\
\hline\end{array}
$
\\
\begin{enumerate}
	\item Eine Maschine, die f"ur die LOAD Instruktion 6 Taktzyklen braucht, ist also\\$ 3.5/3.0 - 1 = 16.7\% $ langsamer.
	\item Eine CPU, bei der die ALU doppelt so schnell arbeitet, ist also\\$ 2.75/3.0 -1 = 8.3\% $ schneller.
\end{enumerate}

\subsection{Aufgabe 2}
\begin{enumerate}
	\item Darauf kann die R"ucksprungadresse f"ur die Vortsetzung der Programmbearbeitung gespeichert werden.
	\item Darauf k"onnen die Aufrufparameter gelegt werden, damit sie von der Subroutine gelesen werden k"onnen.
\end{enumerate}

\subsection{Aufgabe 3}
Damit der Overflow behandelt werden kann: \\\\
$
\begin{array}{|c|c|c|c|c|c|c|}
Vorzeichen A & Vorzeichen B & B invert & Carry out & Vorz. Result. & Korr. Vorz. Res. & Overflow\\
\hline
0&0&0&0&0&0&0\\
0&0&1&0&1&0&1\\
0&1&0&0&1&1&0\\
0&1&1&1&0&0&0\\
1&0&0&0&1&1&0\\
1&0&1&1&0&0&0\\
1&1&0&1&0&1&1\\
1&1&1&1&1&1&0\\
\hline\end{array}
$ \\\\
Die ersten 5 Argumente werden f"ur die Overflowdetection gebraucht. 
Ist das B invert Bit nicht gleich dem Carry out Bit, so gibt es einen Overflow. (Bei ALU31, da da die Vorzeichen abgespeichert sind)

\subsection{Aufgabe 4}
\begin{itemize}
	\item Beim slt-Befehl wird a-b gerechnet. Falls & a-b < 0 & erh"alt man im Vorzeichenbit (ALU31) eine 1.
	\item Die ALU unterst"utzt diesen Befehl, indem sie das Set des ALU31 Bits mit dem Less des ALU0 Bits verbindet. 
	Alle anderen Less sind 0;
\end{itemize}

\subsection{Aufgabe 5}
\begin{lstlisting}[caption=MIPS push und pop]
# Push und pop auf dem Stack. $sp bezeichnet den Stackpointer.
push:
subi $sp $sp 4
sw  $t0 0($sp)

pop:
lw $t0 0($sp)
addi $sp $sp 4
\end{lstlisting}
$

\subsection{Aufgabe 6}

\subsection{Aufgabe 7}


\end{document}
